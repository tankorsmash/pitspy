from typing import Any, Never, TypeVar, Self
import types

import datetime

from dataclasses import dataclass
from enum import Enum

from pathlib import Path

# import humps

from pitspy.types import AnnotationDict, PitspyCustomMatch, PitspyNode
from pitspy.core import get_annotation_tree, traverse_tree_orderly, PitspyTypeMeta

""" elm
type alias Foo = {
    name: String;
    name2: String;
    age: Int;
}
"""


ELM_HEADER = """\
-- This file is auto-generated by pitspy, it was last generated: {now} */\n\n
"""

class TsBaseType(Enum):
	NOT_BASE = ''
	UNDEFINED = 'undefined'
	NULL = 'null'
	NUMBER = 'number'
	STRING = 'string'
	BOOLEAN = 'boolean'
	CUSTOM = 'custom'
	GENERIC = 'generic'
	ANY = 'any'


class TsMutableType(Enum):
	NOT_MUT = 0
	DICT = 1
	ARRAY = 2
	TUPLE = 3


class TsOpType(Enum):
	NOT_OP = 0
	UNION = 1
	INTERSECT = 2

# CUSTOM_HANDLERS tuple[PitspyCustomMatch, ...]= []


@dataclass(frozen=True, kw_only=True)
class ElmAnnotation:
	op: TsOpType = TsOpType.NOT_OP
	base: TsBaseType = TsBaseType.NOT_BASE
	mutable: TsMutableType = TsMutableType.NOT_MUT
	arguments: list[Self] | None = None
	custom_match: PitspyCustomMatch | None = None
	obj_ref: type[Any] | None = None

	@property
	def is_custom(self) -> bool:
		return self.base == TsBaseType.CUSTOM

	@property
	def is_op(self) -> bool:
		return self.op != TsOpType.NOT_OP

	@property
	def is_base(self) -> bool:
		return self.base != TsBaseType.NOT_BASE

	@property
	def is_mutable(self) -> bool:
		return self.mutable != TsMutableType.NOT_MUT

def _py_to_ts_base(py_cls: type[Any]) -> TsBaseType:
	if py_cls.__class__ == Any.__class__:
		return TsBaseType.ANY

	if py_cls.__class__ == TypeVar:
		return TsBaseType.GENERIC

	return {
		types.NoneType: TsBaseType.NULL,
		int: TsBaseType.NUMBER,
		float: TsBaseType.NUMBER,
		str: TsBaseType.STRING,
		bool: TsBaseType.BOOLEAN
	}.get(py_cls, TsBaseType.NOT_BASE)


def _py_to_ts_op(py_cls: type[Any]) -> TsOpType:
	if isinstance(py_cls, types.UnionType):
		return TsOpType.UNION

	return TsOpType.NOT_OP


def _py_to_ts_mutable(py_cls: type[Any]) -> TsMutableType:
	if not isinstance(py_cls, types.GenericAlias):
		return TsMutableType.NOT_MUT

	if py_cls.__origin__ == dict:
		return TsMutableType.DICT
	elif py_cls.__origin__ == list:
		return TsMutableType.ARRAY
	elif py_cls.__origin__ == tuple:
		return TsMutableType.TUPLE
	elif py_cls.__origin__ == set:
		return TsMutableType.ARRAY

	return TsMutableType.NOT_MUT

def py_annotation_to_ts_annotation(pytation: type[Any]) -> 'ElmAnnotation':
	op = _py_to_ts_op(pytation)
	base = _py_to_ts_base(pytation)
	mutable = _py_to_ts_mutable(pytation)
	args: list['ElmAnnotation'] | None = None
	custom_match: PitspyCustomMatch | None = None

	# for handler in []: #CUSTOM_HANDLERS:
	# 	if handler.match(pytation):
	# 		custom_match = handler
	# 		base = TsBaseType.CUSTOM
	# 		break

	if base == TsBaseType.NOT_BASE and (
		op != TsOpType.NOT_OP
		or mutable != TsMutableType.NOT_MUT
	):
		args = [
			py_annotation_to_ts_annotation(a)
			for a in pytation.__args__ #type: ignore
		]

		return ElmAnnotation(
			op=op,
			base=base,
			mutable=mutable,
			arguments=args,
			obj_ref=pytation,
			custom_match=custom_match
		)

	return ElmAnnotation(
		op=op,
		base=base,
		mutable=mutable,
		arguments=args,
		obj_ref=pytation,
		custom_match=custom_match
	)


def elm_annotation_reducer(annot: AnnotationDict) -> AnnotationDict:
# def elm_annotation_reducer(annot: AnnotationDict) -> 'ElmAnnotation':
	result: dict[str, 'ElmAnnotation'] = {}

	for var_name, annotation in annot.items():
		result[var_name] = py_annotation_to_ts_annotation(annotation)

	return result


def get_elm_annotation_tree() -> PitspyNode[AnnotationDict]:
	return get_annotation_tree(
		annotation_reducer=elm_annotation_reducer
	)

def write_elm_annotation_tree_to_interfaces_elm(
	output_path: Path
	) -> None:
	tree = get_annotation_tree()
	header = ELM_HEADER.format(now=datetime.datetime.now().isoformat())

	with output_path.open(encoding='UTF-8', mode='w') as output:
		output.write(header)

	def write_node(_: str, node: PitspyNode['ElmAnnotation']) -> None:
		for leaf_key, leaf in node.leafs.items():
			print("leaf", leaf_key, leaf)

	traverse_tree_orderly(
			tree,
			write_node
		)



